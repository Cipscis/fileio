{"version":3,"file":"docs-script.bundle.js","mappings":"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","sources":["webpack://@cipscis/fileio/./src/readmethod.ts","webpack://@cipscis/fileio/./src/load.ts","webpack://@cipscis/fileio/./node_modules/@cipscis/csv/dist/csv.js","webpack://@cipscis/fileio/./src/save.ts","webpack://@cipscis/fileio/./docs/assets/js/src/docs-script.ts"],"sourcesContent":["enum ReadMethod {\n\tArrayBuffer = 'arrayBuffer',\n\tBinaryString = 'binaryString',\n\tDataUrl = 'dataUrl',\n\tText = 'text',\n\tFile = 'file',\n}\n\nexport { ReadMethod };\n","import { ReadMethod } from './readmethod.js';\n\n/**\n * Load a file via the browser's built-in file selection field.\n *\n * WARNING: If the user chooses not to select a file, the returned Promise will never resolve or reject.\n *\n * @param  {ReadMethod} readMethod - A string representing the way the data to be loaded is represented. Available options are exposed via fileio.ReadMethod\n *\n * @throws {DOMException} - Thrown if reading a File object fails.\n * @throws {RangeError} - readMethod must be a recognised ReadMethod.\n *\n * @return {Promise} Resolves with the contents of the selected file.\n */\nfunction load(readMethod: ReadMethod.ArrayBuffer): Promise<ArrayBuffer>\nfunction load(readMethod?: ReadMethod.BinaryString | ReadMethod.DataUrl | ReadMethod.Text): Promise<string>\nfunction load(readMethod: ReadMethod.File): Promise<File>;\nfunction load(readMethod?: ReadMethod): Promise<File | string | ArrayBuffer> {\n\treadMethod = readMethod ?? ReadMethod.Text;\n\n\treturn new Promise((resolve, reject) => {\n\t\tfunction fileLoaded(this: FileReader, e: ProgressEvent<FileReader>) {\n\t\t\tconst reader = this;\n\n\t\t\tif (reader.readyState === FileReader.DONE) {\n\t\t\t\tif (reader.result) {\n\t\t\t\t\tresolve(reader.result);\n\t\t\t\t} else {\n\t\t\t\t\tif (reader.error) {\n\t\t\t\t\t\treject(reader.error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treject(new DOMException('Error parsing file'));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfunction readFile(file: File): void {\n\t\t\tconst reader = new FileReader();\n\n\t\t\treader.addEventListener('load', fileLoaded);\n\t\t\treader.addEventListener('error', () => {\n\t\t\t\treader.abort();\n\t\t\t\tif (reader.error) {\n\t\t\t\t\treject(reader.error);\n\t\t\t\t} else {\n\t\t\t\t\treject(new DOMException('Error parsing file'));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tswitch (readMethod) {\n\t\t\t\tcase ReadMethod.ArrayBuffer:\n\t\t\t\t\treader.readAsArrayBuffer(file);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ReadMethod.BinaryString:\n\t\t\t\t\treader.readAsBinaryString(file);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ReadMethod.DataUrl:\n\t\t\t\t\treader.readAsDataURL(file);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ReadMethod.Text:\n\t\t\t\t\treader.readAsText(file);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treject(new RangeError(`FileIO: Unrecognised readMethod ${readMethod}`));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\n\t\t// @ts-ignore This function doesn't exist for all browsers, but @types/wicg-file-system-access doesn't make it optional\n\t\tif (window.showOpenFilePicker) {\n\t\t\twindow.showOpenFilePicker().then(async ([handle]) => {\n\t\t\t\tif (handle.kind === 'file') {\n\t\t\t\t\tconst file = await handle.getFile();\n\n\t\t\t\t\tif (readMethod === ReadMethod.File) {\n\t\t\t\t\t\tresolve(file);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treadFile(file);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treject();\n\t\t\t\t}\n\t\t\t}).catch(reject);\n\t\t} else {\n\t\t\tfunction loadSelectedFileEvent(this: HTMLInputElement, e: Event): void {\n\t\t\t\tconst $fileInput = this;\n\n\t\t\t\tconst files = $fileInput.files;\n\t\t\t\tif (files && files.length > 0) {\n\t\t\t\t\tconst file = files[0];\n\n\t\t\t\t\tif (readMethod === ReadMethod.File) {\n\t\t\t\t\t\tresolve(file);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treadFile(file);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst $fileInput = document.createElement('input');\n\t\t\t$fileInput.type = 'file';\n\t\t\t$fileInput.addEventListener('change', loadSelectedFileEvent);\n\n\t\t\t$fileInput.click();\n\t\t}\n\t});\n}\n\nexport { load, ReadMethod };\n","/**\r\n * Converts a 2D Array into a CSV string.\r\n *\r\n * `stringify` converts most falsey values into empty cells. `undefined`, `''`, and `[]` are all treated this way. `null` and `false`, however, are converted into string representations when stringifying CSV data.\r\n *\r\n * If you need to maintain a value of `undefined`, `''`, or `[]` when stringifying your CSV data, convert it to a string first (e.g. `'undefined'`)\r\n *\r\n * @param {any[][]} data - A 2D Array to convert into a CSV string.\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {string} CSV string\r\n */\r\nfunction stringify(data, options) {\r\n    options = options || {};\r\n    options.transpose = options.transpose || false;\r\n    options.sanitise = options.sanitise || false;\r\n    // Enforce square data and apply CSV escaping, then convert to string\r\n    const rows = data;\r\n    const shapedRows = _shape(data, options);\r\n    const escapedRows = _escape(shapedRows, options);\r\n    const joinedRows = _join(escapedRows);\r\n    return joinedRows;\r\n}\r\n/**\r\n * Pad missing cells with empty strings and, if necessary, transpose the data\r\n *\r\n * @param {any[][]} data - A 2D Array to pad and potentially transpose.\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {any[][]} Shaped CSV data\r\n */\r\nfunction _shape(data, options) {\r\n    const transpose = options?.transpose ?? false;\r\n    const maxLength = data.reduce((maxLength, row) => Math.max(maxLength, row.length), 0);\r\n    // Flip rows and columns if transposing data\r\n    const iMax = transpose ? maxLength : data.length;\r\n    const jMax = transpose ? data.length : maxLength;\r\n    const rows = [];\r\n    for (let i = 0; i < iMax; i++) {\r\n        const row = [];\r\n        for (let j = 0; j < jMax; j++) {\r\n            const iRow = transpose ? j : i;\r\n            const iCol = transpose ? i : j;\r\n            let cellValue = data[iRow][iCol];\r\n            if (iCol >= data[iRow].length) {\r\n                cellValue = '';\r\n            }\r\n            row.push(cellValue);\r\n        }\r\n        rows.push(row);\r\n    }\r\n    return rows;\r\n}\r\n/**\r\n * Make sure any cells containing \" or , or a newline are escaped appropriately\r\n *\r\n * @param {any[][]} rows - A 2D Array with values to escape\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {string[][]} Escaped CSV data\r\n */\r\nfunction _escape(rows, options) {\r\n    for (const row of rows) {\r\n        for (let j = 0; j < row.length; j++) {\r\n            row[j] = _escapeCell(row[j], options);\r\n        }\r\n    }\r\n    return rows;\r\n}\r\n/**\r\n * Make sure any cells containing \" or , or a newline are escaped appropriately\r\n *\r\n * @param {any} cell - A single value to escape\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {string} Escaped value\r\n */\r\nfunction _escapeCell(cell, options) {\r\n    const sanitise = options?.sanitise ?? false;\r\n    // Convert to string\r\n    let cellString;\r\n    if (typeof cell === 'undefined') {\r\n        // Replace undefined with ''\r\n        cellString = '';\r\n    }\r\n    else if (typeof cell !== 'string') {\r\n        // Convert to string\r\n        cellString = '' + cell;\r\n    }\r\n    else {\r\n        cellString = cell;\r\n    }\r\n    // Sanitise\r\n    if (sanitise) {\r\n        // Prevent spreadsheet software like\r\n        // Excel from trying to execute code\r\n        if (cellString.match(/^[=\\-+@]/)) {\r\n            cellString = '\\t' + cell;\r\n        }\r\n    }\r\n    // Escape\r\n    if (cellString.match(/,|\"|\\n/)) {\r\n        // Turn any double quotes into escaped double quotes\r\n        cellString = cellString.replace(/\"/g, '\"\"');\r\n        // Wrap cell in double quotes\r\n        cellString = '\"' + cellString + '\"';\r\n    }\r\n    return cellString;\r\n}\r\n/**\r\n * Join escaped CSV data into a single string.\r\n *\r\n * @param  {string[][]} rows - A 2D Array containing escaped CSV data\r\n *\r\n * @return {string} A CSV string\r\n */\r\nfunction _join(rows) {\r\n    const rowStrings = [];\r\n    for (let i = 0; i < rows.length; i++) {\r\n        rowStrings.push(rows[i].join(','));\r\n    }\r\n    const rowsString = rowStrings.join('\\n');\r\n    return rowsString;\r\n}\r\nfunction parse(csvString, mapper) {\r\n    const stringRows = _tokenise(csvString);\r\n    _validate(stringRows);\r\n    if (typeof mapper !== 'undefined') {\r\n        const dataRows = stringRows.map((row) => row.map(mapper));\r\n        return dataRows;\r\n    }\r\n    else {\r\n        return stringRows;\r\n    }\r\n}\r\n/**\r\n * Walk through each character and produce an array of cell values. Throws an error if the string is not formatted as expected for a CSV.\r\n *\r\n * @param {string} csvString - A string representation of a CSV.\r\n *\r\n * @throws {SyntaxError} - The csvString must not be malformed.\r\n */\r\nfunction _tokenise(csvString) {\r\n    // Walk through each character and produce an array of tokens\r\n    const tokens = [];\r\n    // Remove carriage returns\r\n    csvString = csvString.replace(/\\r/g, '');\r\n    let inQuote = false;\r\n    let wasQuote = false;\r\n    let tokenStart = 0;\r\n    let row = [];\r\n    for (let i = 0; i < csvString.length; i++) {\r\n        const char = csvString[i];\r\n        const comma = char === ',';\r\n        const quote = char === '\"';\r\n        const newline = char === '\\n';\r\n        const eof = i === csvString.length - 1; // eof - End Of File\r\n        if (inQuote) {\r\n            // Characters may be delimited\r\n            if (quote) {\r\n                // Check if the next character is another double quote, i.e. if it is escaped\r\n                const nextChar = csvString[i + 1];\r\n                if (nextChar === '\"') {\r\n                    // This and the next character combined make an escaped double quote,\r\n                    // so the quote has not ended and we should skip over the next character\r\n                    i++;\r\n                    continue;\r\n                }\r\n                else {\r\n                    // The quote has ended\r\n                    inQuote = false;\r\n                    wasQuote = true;\r\n                    if (!eof) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n            else if (eof) {\r\n                throw new SyntaxError(`CSV parse: Reached end of file before ending quote. At index ${i}`);\r\n            }\r\n        }\r\n        if (!inQuote && (comma || newline || eof)) {\r\n            // These are the characters that denote the end of a token\r\n            let token = csvString.substring(tokenStart, i + 1);\r\n            if (comma || newline) {\r\n                // Don't keep the separator\r\n                token = token.substring(0, token.length - 1);\r\n            }\r\n            if (wasQuote) {\r\n                wasQuote = false;\r\n                // Remove start and end quotes\r\n                token = token.substring(1, token.length - 1);\r\n                // Replace escaped quotes\r\n                token = token.replace(/\"\"/g, '\"');\r\n            }\r\n            row.push(token);\r\n            if (comma && eof) {\r\n                // It's the end of the last token, and the last cell is empty\r\n                row.push('');\r\n            }\r\n            if (newline || eof) {\r\n                tokens.push(row);\r\n                if (newline) {\r\n                    row = [];\r\n                }\r\n            }\r\n            tokenStart = i + 1;\r\n        }\r\n        else if (wasQuote) {\r\n            throw new SyntaxError(`CSV parse: A value must be complete immediately after closing a quote. At index ${i}`);\r\n        }\r\n        else if (quote) {\r\n            inQuote = true;\r\n        }\r\n    }\r\n    return tokens;\r\n}\r\n/**\r\n * Checks that an array of CSV values is rectangular, i.e. that each row has the same length.\r\n *\r\n * Throws a SyntaxError if validation fails.\r\n *\r\n * @param {string[][]} rows - A 2D array of CSV values.\r\n *\r\n * @throws {SyntaxError} - The rows 2D Array must not be malformed.\r\n */\r\nfunction _validate(rows) {\r\n    // Each row of a CSV should have the same length;\r\n    if (rows && rows.length > 1) {\r\n        let rowLength = rows[0].length;\r\n        for (let i = 1; i < rows.length; i++) {\r\n            let row = rows[i];\r\n            if (row.length !== rowLength) {\r\n                throw new SyntaxError(`CSV parse: Row ${i} does not have the same length as the first row (${rowLength})`);\r\n            }\r\n        }\r\n    }\r\n}\r\nexport { stringify, parse, };\r\n//# sourceMappingURL=csv.js.map","import { StringifyOptions } from '@cipscis/csv';\nimport * as csv from '@cipscis/csv';\n\ndeclare global {\n\tinterface Navigator {\n\t\tmsSaveBlob?: (blob: any, defaultName?: string) => boolean\n\t}\n}\n\nexport interface SaveOptions extends StringifyOptions {\n\tfilename?: string,\n\ttype?: string,\n\tsaveAs?: boolean,\n}\n\nlet $link: HTMLAnchorElement;\n\n/**\n * Save arbitrary data as a file, using the browser's built-in save file window.\n *\n * @param {any} data - Data to save in a file\n * @param {SaveOptions} [options] - An object containing options for how to save the file.\n * @param {string} [options.filename] - The name to use for the file being saved.\n * @param {string} [options.type] - The type of data being saved.\n *\n * @throws {TypeError} - Thrown if data attempting to be saved as JSON fails to stringify.\n * @throws {DOMException} - Thrown if reading a File object fails.\n */\nfunction save(data: any, options?: SaveOptions): void {\n\tif (data instanceof File) {\n\t\t_saveFile(data, options);\n\t} else if (data instanceof Blob) {\n\t\t_saveBlob(data, options);\n\t} else {\n\t\t_saveData(data, options);\n\t}\n}\n\n/**\n * Save data that you have as a Blob.\n *\n * @param {Blob} blob - Data to save.\n * @param {SaveOptions} [options] - An object containing options for how to save the file.\n * @param {string} [options.filename=file] - The name to use for the file being saved.\n */\nfunction _saveBlob(blob: Blob, options?: SaveOptions): void {\n\tif (!(blob instanceof Blob)) {\n\t\tthrow new TypeError('FileIO: save blob requires a Blob');\n\t}\n\n\tconst filename = options?.filename || 'file';\n\n\tif (options?.saveAs && window.showSaveFilePicker) {\n\t\tshowSaveFilePicker({\n\t\t\tsuggestedName: filename,\n\t\t}).then(async (handle) => {\n\t\t\tconst writeableStream = await handle.createWritable();\n\t\t\tawait writeableStream.write(blob);\n\t\t\tawait writeableStream.close();\n\t\t});\n\t} else if (navigator.msSaveBlob) {\n\t\tnavigator.msSaveBlob(blob, filename);\n\t} else {\n\t\tconst url = URL.createObjectURL(blob);\n\t\t_downloadDataUrl(url, filename);\n\t}\n}\n\n/**\n * Save data that you have as a File object.\n *\n * @param {File} file - Data to save.\n * @param {SaveOptions} [options] - An object containing options for how to save the file.\n * @param {string} [options.filename=file] - The name to use for the file being saved. If the File has a name, it will be used by default.\n *\n * @throws {DOMException} - Thrown if reading a File object fails.\n */\nfunction _saveFile(file: File, options?: SaveOptions): void {\n\tif (!(file instanceof File)) {\n\t\tthrow new TypeError('FileIO: save file requires a File');\n\t}\n\n\tconst filename = options?.filename || file.name || 'file';\n\n\tif (options?.saveAs && window.showSaveFilePicker) {\n\t\tshowSaveFilePicker({\n\t\t\tsuggestedName: filename,\n\t\t}).then(async (handle) => {\n\t\t\tconst writeableStream = await handle.createWritable();\n\t\t\tawait writeableStream.write(file);\n\t\t\tawait writeableStream.close();\n\t\t});\n\t} else if (navigator.msSaveBlob) {\n\t\tnavigator.msSaveBlob(file, filename);\n\t} else {\n\t\tconst reader = new FileReader();\n\n\t\treader.addEventListener('load', function () {\n\t\t\tif (reader.readyState === FileReader.DONE) {\n\t\t\t\tif (reader.result) {\n\t\t\t\t\t// Because we called readAsDataURL,\n\t\t\t\t\t// the result will be a string\n\t\t\t\t\tconst result = reader.result as string;\n\n\t\t\t\t\t_downloadDataUrl(result, filename);\n\t\t\t\t} else {\n\t\t\t\t\tif (reader.error) {\n\t\t\t\t\t\tthrow reader.error;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new DOMException('Error parsing file');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treader.addEventListener('error', () => {\n\t\t\treader.abort();\n\t\t\tif (reader.error) {\n\t\t\t\tthrow reader.error;\n\t\t\t} else {\n\t\t\t\tthrow new DOMException('Error parsing file');\n\t\t\t}\n\t\t});\n\n\t\treader.readAsDataURL(file);\n\t}\n}\n\n/**\n * Save arbitary data as a file.\n *\n * @param {any} data - Data to save as a file.\n * @param {SaveOptions} [options] - An object containing options for how to save the file.\n * @param {string} [options.filename=file] - The name to use for the file being saved.\n * @param {string} [options.type] - The type of data being saved.\n *\n * @throws {TypeError} - Thrown if data attempting to be saved as JSON fails to stringify.\n */\nfunction _saveData(data: any, options?: SaveOptions): void {\n\tlet filename = options?.filename || 'file';\n\tlet type = options?.type || 'text/plain'\n\n\t// Type shorthands\n\tswitch (type) {\n\t\tcase 'json':\n\t\t\ttype = 'application/json';\n\t\t\tbreak;\n\t\tcase 'csv':\n\t\t\ttype = 'text/csv';\n\t\t\tbreak;\n\t}\n\n\tif (type === 'application/json') {\n\t\t// May throw an error\n\t\tdata = JSON.stringify(data);\n\n\t\tfilename = _extendFilename(filename, 'json');\n\t} else if (type === 'text/csv') {\n\t\tif (typeof data !== 'string') {\n\t\t\tdata = csv.stringify(data, options);\n\t\t}\n\t\tfilename = _extendFilename(filename, 'csv');\n\t}\n\n\t// Construct a Blob and download it\n\tlet blob = new Blob(\n\t\t[data],\n\t\t{ type }\n\t);\n\n\t_saveBlob(blob, options);\n}\n\n/**\n * Download a file by using a Data URL to click an anchor.\n *\n * @param {string} dataUrl - The Data URL to download.\n * @param {string} filename - The name of the file to be downloaded.\n */\nfunction _downloadDataUrl(dataUrl: string, filename: string): void {\n\t$link = $link || document.createElement('a');\n\t$link.href = dataUrl;\n\t$link.download = filename;\n\t$link.click();\n\n\tURL.revokeObjectURL(dataUrl);\n}\n\n/**\n * Adds a file extension to a filename if it doesn't already have one.\n *\n * @param  {string} filename - The file name to extend\n * @param  {string} extension - The extension to add. Don't include the '.'\n *\n * @return {string} `${filename}.${extension}`\n */\nfunction _extendFilename(filename: string, extension: string): string {\n\tlet testPattern = new RegExp('\\\\.' + extension + '$');\n\n\tif (!testPattern.test(filename)) {\n\t\tfilename += '.' + extension;\n\t}\n\n\treturn filename;\n}\n\nexport { save };\n","import * as fileIO from '@cipscis/fileio';\n\nlet saveAs = false;\nconst toggleSaveAs = () => {\n\tsaveAs = !saveAs;\n\tconst $saveAsValue = document.querySelector<HTMLElement>('.js-save-as-value');\n\tif ($saveAsValue) {\n\t\t$saveAsValue.innerText = saveAs.toString();\n\t}\n};\ndocument.querySelectorAll('.js-save-as-toggle').forEach(($el) => $el.addEventListener('click', toggleSaveAs));\n\nconst loadImage = (fileUrl: string) => {\n\tconst $image = document.querySelectorAll('.js-fileio-image') as NodeListOf<HTMLImageElement>;\n\t$image.forEach(($image) => $image.src = fileUrl);\n};\ndocument.querySelectorAll('.js-load-image').forEach(($el) => $el.addEventListener('click', () => {\n\tfileIO.load(fileIO.ReadMethod.DataUrl).then(loadImage);\n}));\n\nconst saveData = () => {\n\tconst data = 'Hey look, the file has some content!';\n\tconst filename = 'test file.txt';\n\tconst type = 'text/plain';\n\n\tfileIO.save(data, { filename, type, saveAs });\n};\ndocument.querySelectorAll('.js-save-data').forEach(($el) => $el.addEventListener('click', saveData));\n\nconst saveJson = () => {\n\tconst data = {\n\t\ttext: 1,\n\t\tfoo: 'bar'\n\t};\n\tconst filename = 'test json';\n\n\tconsole.log('test');\n\tfileIO.save(data, { filename, type: 'json', saveAs });\n};\ndocument.querySelectorAll('.js-save-json').forEach(($el) => $el.addEventListener('click', saveJson));\n\nconst saveCsv = () => {\n\tconst data = [\n\t\t['even numbers', 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24],\n\t\t['odd numbers', 1, 3, 5, 7, 9],\n\t\t['prime numbers, up to ten', 2, 3, 5, 7]\n\t];\n\tconst filename = 'test csv';\n\n\tfileIO.save(data, {filename, type: 'csv', saveAs, transpose: true });\n};\ndocument.querySelectorAll('.js-save-csv').forEach(($el) => $el.addEventListener('click', saveCsv));\n\nconst saveFile = async () => {\n\tconst file = await fileIO.load(fileIO.ReadMethod.File);\n\tfileIO.save(file, { saveAs });\n};\ndocument.querySelectorAll('.js-save-file').forEach(($el) => $el.addEventListener('click', saveFile));\n"],"names":["ReadMethod","load","readMethod","Text","Promise","resolve","reject","fileLoaded","e","reader","this","readyState","FileReader","DONE","result","error","DOMException","readFile","file","addEventListener","abort","ArrayBuffer","readAsArrayBuffer","BinaryString","readAsBinaryString","DataUrl","readAsDataURL","readAsText","RangeError","window","showOpenFilePicker","then","async","handle","kind","getFile","File","catch","loadSelectedFileEvent","files","length","$fileInput","document","createElement","type","click","_escapeCell","cell","options","cellString","sanitise","match","replace","$link","save","data","TypeError","filename","name","saveAs","showSaveFilePicker","suggestedName","writeableStream","createWritable","write","close","navigator","msSaveBlob","_downloadDataUrl","_saveFile","Blob","_saveBlob","JSON","stringify","_extendFilename","transpose","rows","rowStrings","i","push","join","_join","row","j","_escape","maxLength","reduce","Math","max","iMax","jMax","iRow","iCol","cellValue","_shape","_saveData","blob","URL","createObjectURL","dataUrl","href","download","revokeObjectURL","extension","RegExp","test","toggleSaveAs","$saveAsValue","querySelector","innerText","toString","querySelectorAll","forEach","$el","loadImage","fileUrl","$image","src","saveData","saveJson","console","log","text","foo","saveCsv","saveFile"],"sourceRoot":""}