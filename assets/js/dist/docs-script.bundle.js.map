{"version":3,"file":"docs-script.bundle.js","mappings":"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","sources":["webpack://@cipscis/fileio/./src/readmethod.ts","webpack://@cipscis/fileio/./src/load.ts","webpack://@cipscis/fileio/./node_modules/@cipscis/csv/dist/csv.js","webpack://@cipscis/fileio/./src/save.ts","webpack://@cipscis/fileio/./docs/assets/js/src/docs-script.ts"],"sourcesContent":["enum ReadMethod {\n\tArrayBuffer = 'arrayBuffer',\n\tBinaryString = 'binaryString',\n\tDataUrl = 'dataUrl',\n\tText = 'text',\n\tFile = 'file',\n}\n\nexport { ReadMethod };\n","import { ReadMethod } from './readmethod.js';\n\n/**\n * Load a file via the browser's built-in file selection field.\n *\n * WARNING: If the user chooses not to select a file, the returned Promise will never resolve or reject.\n *\n * @param  {ReadMethod} readMethod - A string representing the way the data to be loaded is represented. Available options are exposed via fileio.ReadMethod\n *\n * @throws {DOMException} - Thrown if reading a File object fails.\n * @throws {RangeError} - readMethod must be a recognised ReadMethod.\n *\n * @return {Promise} Resolves with the contents of the selected file.\n */\nfunction load(readMethod: ReadMethod.ArrayBuffer): Promise<ArrayBuffer>\nfunction load(readMethod?: ReadMethod.BinaryString | ReadMethod.DataUrl | ReadMethod.Text): Promise<string>\nfunction load(readMethod: ReadMethod.File): Promise<File>;\nfunction load(readMethod?: ReadMethod): Promise<File | string | ArrayBuffer> {\n\treadMethod = readMethod ?? ReadMethod.Text;\n\n\treturn new Promise((resolve, reject) => {\n\t\tfunction fileLoaded(this: FileReader, e: ProgressEvent<FileReader>) {\n\t\t\tconst reader = this;\n\n\t\t\tif (reader.readyState === FileReader.DONE) {\n\t\t\t\tif (reader.result) {\n\t\t\t\t\tresolve(reader.result);\n\t\t\t\t} else {\n\t\t\t\t\tif (reader.error) {\n\t\t\t\t\t\treject(reader.error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treject(new DOMException('Error parsing file'));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfunction readFile(file: File): void {\n\t\t\tconst reader = new FileReader();\n\n\t\t\treader.addEventListener('load', fileLoaded);\n\t\t\treader.addEventListener('error', () => {\n\t\t\t\treader.abort();\n\t\t\t\tif (reader.error) {\n\t\t\t\t\treject(reader.error);\n\t\t\t\t} else {\n\t\t\t\t\treject(new DOMException('Error parsing file'));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tswitch (readMethod) {\n\t\t\t\tcase ReadMethod.ArrayBuffer:\n\t\t\t\t\treader.readAsArrayBuffer(file);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ReadMethod.BinaryString:\n\t\t\t\t\treader.readAsBinaryString(file);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ReadMethod.DataUrl:\n\t\t\t\t\treader.readAsDataURL(file);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ReadMethod.Text:\n\t\t\t\t\treader.readAsText(file);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treject(new RangeError(`FileIO: Unrecognised readMethod ${readMethod}`));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\n\t\tfunction loadSelectedFileEvent(this: HTMLInputElement, e: Event): void {\n\t\t\tconst $fileInput = this;\n\n\t\t\tconst files = $fileInput.files;\n\t\t\tif (files && files.length > 0) {\n\t\t\t\tconst file = files[0];\n\n\t\t\t\tif (readMethod === ReadMethod.File) {\n\t\t\t\t\tresolve(file);\n\t\t\t\t} else {\n\t\t\t\t\treadFile(file);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst $fileInput = document.createElement('input');\n\t\t$fileInput.type = 'file';\n\t\t$fileInput.addEventListener('change', loadSelectedFileEvent);\n\n\t\t$fileInput.click();\n\t});\n}\n\nexport { load, ReadMethod };\n","/**\r\n * Converts a 2D Array into a CSV string.\r\n *\r\n * `stringify` converts most falsey values into empty cells. `undefined`, `''`, and `[]` are all treated this way. `null` and `false`, however, are converted into string representations when stringifying CSV data.\r\n *\r\n * If you need to maintain a value of `undefined`, `''`, or `[]` when stringifying your CSV data, convert it to a string first (e.g. `'undefined'`)\r\n *\r\n * @param {any[][]} data - A 2D Array to convert into a CSV string.\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {string} CSV string\r\n */\r\nfunction stringify(data, options) {\r\n    options = options || {};\r\n    options.transpose = options.transpose || false;\r\n    options.sanitise = options.sanitise || false;\r\n    // Enforce square data and apply CSV escaping, then convert to string\r\n    const rows = data;\r\n    const shapedRows = _shape(data, options);\r\n    const escapedRows = _escape(shapedRows, options);\r\n    const joinedRows = _join(escapedRows);\r\n    return joinedRows;\r\n}\r\n/**\r\n * Pad missing cells with empty strings and, if necessary, transpose the data\r\n *\r\n * @param {any[][]} data - A 2D Array to pad and potentially transpose.\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {any[][]} Shaped CSV data\r\n */\r\nfunction _shape(data, options) {\r\n    const transpose = options?.transpose ?? false;\r\n    const maxLength = data.reduce((maxLength, row) => Math.max(maxLength, row.length), 0);\r\n    // Flip rows and columns if transposing data\r\n    const iMax = transpose ? maxLength : data.length;\r\n    const jMax = transpose ? data.length : maxLength;\r\n    const rows = [];\r\n    for (let i = 0; i < iMax; i++) {\r\n        const row = [];\r\n        for (let j = 0; j < jMax; j++) {\r\n            const iRow = transpose ? j : i;\r\n            const iCol = transpose ? i : j;\r\n            let cellValue = data[iRow][iCol];\r\n            if (iCol >= data[iRow].length) {\r\n                cellValue = '';\r\n            }\r\n            row.push(cellValue);\r\n        }\r\n        rows.push(row);\r\n    }\r\n    return rows;\r\n}\r\n/**\r\n * Make sure any cells containing \" or , or a newline are escaped appropriately\r\n *\r\n * @param {any[][]} rows - A 2D Array with values to escape\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {string[][]} Escaped CSV data\r\n */\r\nfunction _escape(rows, options) {\r\n    for (const row of rows) {\r\n        for (let j = 0; j < row.length; j++) {\r\n            row[j] = _escapeCell(row[j], options);\r\n        }\r\n    }\r\n    return rows;\r\n}\r\n/**\r\n * Make sure any cells containing \" or , or a newline are escaped appropriately\r\n *\r\n * @param {any} cell - A single value to escape\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {string} Escaped value\r\n */\r\nfunction _escapeCell(cell, options) {\r\n    const sanitise = options?.sanitise ?? false;\r\n    // Convert to string\r\n    let cellString;\r\n    if (typeof cell === 'undefined') {\r\n        // Replace undefined with ''\r\n        cellString = '';\r\n    }\r\n    else if (typeof cell !== 'string') {\r\n        // Convert to string\r\n        cellString = '' + cell;\r\n    }\r\n    else {\r\n        cellString = cell;\r\n    }\r\n    // Sanitise\r\n    if (sanitise) {\r\n        // Prevent spreadsheet software like\r\n        // Excel from trying to execute code\r\n        if (cellString.match(/^[=\\-+@]/)) {\r\n            cellString = '\\t' + cell;\r\n        }\r\n    }\r\n    // Escape\r\n    if (cellString.match(/,|\"|\\n/)) {\r\n        // Turn any double quotes into escaped double quotes\r\n        cellString = cellString.replace(/\"/g, '\"\"');\r\n        // Wrap cell in double quotes\r\n        cellString = '\"' + cellString + '\"';\r\n    }\r\n    return cellString;\r\n}\r\n/**\r\n * Join escaped CSV data into a single string.\r\n *\r\n * @param  {string[][]} rows - A 2D Array containing escaped CSV data\r\n *\r\n * @return {string} A CSV string\r\n */\r\nfunction _join(rows) {\r\n    const rowStrings = [];\r\n    for (let i = 0; i < rows.length; i++) {\r\n        rowStrings.push(rows[i].join(','));\r\n    }\r\n    const rowsString = rowStrings.join('\\n');\r\n    return rowsString;\r\n}\r\nfunction parse(csvString, mapper) {\r\n    const stringRows = _tokenise(csvString);\r\n    _validate(stringRows);\r\n    if (typeof mapper !== 'undefined') {\r\n        const dataRows = stringRows.map((row) => row.map(mapper));\r\n        return dataRows;\r\n    }\r\n    else {\r\n        return stringRows;\r\n    }\r\n}\r\n/**\r\n * Walk through each character and produce an array of cell values. Throws an error if the string is not formatted as expected for a CSV.\r\n *\r\n * @param {string} csvString - A string representation of a CSV.\r\n *\r\n * @throws {SyntaxError} - The csvString must not be malformed.\r\n */\r\nfunction _tokenise(csvString) {\r\n    // Walk through each character and produce an array of tokens\r\n    const tokens = [];\r\n    // Remove carriage returns\r\n    csvString = csvString.replace(/\\r/g, '');\r\n    let inQuote = false;\r\n    let wasQuote = false;\r\n    let tokenStart = 0;\r\n    let row = [];\r\n    for (let i = 0; i < csvString.length; i++) {\r\n        const char = csvString[i];\r\n        const comma = char === ',';\r\n        const quote = char === '\"';\r\n        const newline = char === '\\n';\r\n        const eof = i === csvString.length - 1; // eof - End Of File\r\n        if (inQuote) {\r\n            // Characters may be delimited\r\n            if (quote) {\r\n                // Check if the next character is another double quote, i.e. if it is escaped\r\n                const nextChar = csvString[i + 1];\r\n                if (nextChar === '\"') {\r\n                    // This and the next character combined make an escaped double quote,\r\n                    // so the quote has not ended and we should skip over the next character\r\n                    i++;\r\n                    continue;\r\n                }\r\n                else {\r\n                    // The quote has ended\r\n                    inQuote = false;\r\n                    wasQuote = true;\r\n                    if (!eof) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n            else if (eof) {\r\n                throw new SyntaxError(`CSV parse: Reached end of file before ending quote. At index ${i}`);\r\n            }\r\n        }\r\n        if (!inQuote && (comma || newline || eof)) {\r\n            // These are the characters that denote the end of a token\r\n            let token = csvString.substring(tokenStart, i + 1);\r\n            if (comma || newline) {\r\n                // Don't keep the separator\r\n                token = token.substring(0, token.length - 1);\r\n            }\r\n            if (wasQuote) {\r\n                wasQuote = false;\r\n                // Remove start and end quotes\r\n                token = token.substring(1, token.length - 1);\r\n                // Replace escaped quotes\r\n                token = token.replace(/\"\"/g, '\"');\r\n            }\r\n            row.push(token);\r\n            if (comma && eof) {\r\n                // It's the end of the last token, and the last cell is empty\r\n                row.push('');\r\n            }\r\n            if (newline || eof) {\r\n                tokens.push(row);\r\n                if (newline) {\r\n                    row = [];\r\n                }\r\n            }\r\n            tokenStart = i + 1;\r\n        }\r\n        else if (wasQuote) {\r\n            throw new SyntaxError(`CSV parse: A value must be complete immediately after closing a quote. At index ${i}`);\r\n        }\r\n        else if (quote) {\r\n            inQuote = true;\r\n        }\r\n    }\r\n    return tokens;\r\n}\r\n/**\r\n * Checks that an array of CSV values is rectangular, i.e. that each row has the same length.\r\n *\r\n * Throws a SyntaxError if validation fails.\r\n *\r\n * @param {string[][]} rows - A 2D array of CSV values.\r\n *\r\n * @throws {SyntaxError} - The rows 2D Array must not be malformed.\r\n */\r\nfunction _validate(rows) {\r\n    // Each row of a CSV should have the same length;\r\n    if (rows && rows.length > 1) {\r\n        let rowLength = rows[0].length;\r\n        for (let i = 1; i < rows.length; i++) {\r\n            let row = rows[i];\r\n            if (row.length !== rowLength) {\r\n                throw new SyntaxError(`CSV parse: Row ${i} does not have the same length as the first row (${rowLength})`);\r\n            }\r\n        }\r\n    }\r\n}\r\nexport { stringify, parse, };\r\n//# sourceMappingURL=csv.js.map","import { StringifyOptions } from '@cipscis/csv';\nimport * as csv from '@cipscis/csv';\n\nexport interface SaveOptions extends StringifyOptions {\n\tfilename?: string,\n\ttype?: string\n}\n\nlet $link: HTMLAnchorElement;\n\n/**\n * Save arbitrary data as a file, using the browser's built-in save file window.\n *\n * @param {any} data - Data to save in a file\n * @param {SaveOptions} [options] - An object containing options for how to save the file.\n * @param {string} [options.filename] - The name to use for the file being saved.\n * @param {string} [options.type] - The type of data being saved.\n *\n * @throws {TypeError} - Thrown if data attempting to be saved as JSON fails to stringify.\n * @throws {DOMException} - Thrown if reading a File object fails.\n */\nfunction save(data: any, options?: SaveOptions): void {\n\tif (data instanceof File) {\n\t\t_saveFile(data, options);\n\t} else if (data instanceof Blob) {\n\t\t_saveBlob(data, options);\n\t} else {\n\t\t_saveData(data, options);\n\t}\n}\n\n/**\n * Save data that you have as a Blob.\n *\n * @param {Blob} blob - Data to save.\n * @param {SaveOptions} [options] - An object containing options for how to save the file.\n * @param {string} [options.filename=file] - The name to use for the file being saved.\n */\nfunction _saveBlob(blob: Blob, options?: SaveOptions): void {\n\tif (!(blob instanceof Blob)) {\n\t\tthrow new TypeError('FileIO: save blob requires a Blob');\n\t}\n\n\tconst filename = options?.filename || 'file';\n\n\tif (navigator.msSaveBlob) {\n\t\tnavigator.msSaveBlob(blob, filename);\n\t} else {\n\t\tconst url = URL.createObjectURL(blob);\n\t\t_downloadDataUrl(url, filename);\n\t}\n}\n\n/**\n * Save data that you have as a File object.\n *\n * @param {File} file - Data to save.\n * @param {SaveOptions} [options] - An object containing options for how to save the file.\n * @param {string} [options.filename=file] - The name to use for the file being saved. If the File has a name, it will be used by default.\n *\n * @throws {DOMException} - Thrown if reading a File object fails.\n */\nfunction _saveFile(file: File, options?: SaveOptions): void {\n\tif (!(file instanceof File)) {\n\t\tthrow new TypeError('FileIO: save file requires a File');\n\t}\n\n\tconst filename = options?.filename || file.name || 'file';\n\n\tif (navigator.msSaveBlob) {\n\t\tnavigator.msSaveBlob(file, filename);\n\t} else {\n\t\tconst reader = new FileReader();\n\n\t\treader.addEventListener('load', function () {\n\t\t\tif (reader.readyState === FileReader.DONE) {\n\t\t\t\tif (reader.result) {\n\t\t\t\t\t// Because we called readAsDataURL,\n\t\t\t\t\t// the result will be a string\n\t\t\t\t\tconst result = reader.result as string;\n\n\t\t\t\t\t_downloadDataUrl(result, filename);\n\t\t\t\t} else {\n\t\t\t\t\tif (reader.error) {\n\t\t\t\t\t\tthrow reader.error;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new DOMException('Error parsing file');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treader.addEventListener('error', () => {\n\t\t\treader.abort();\n\t\t\tif (reader.error) {\n\t\t\t\tthrow reader.error;\n\t\t\t} else {\n\t\t\t\tthrow new DOMException('Error parsing file');\n\t\t\t}\n\t\t});\n\n\t\treader.readAsDataURL(file);\n\t}\n}\n\n/**\n * Save arbitary data as a file.\n *\n * @param {any} data - Data to save as a file.\n * @param {SaveOptions} [options] - An object containing options for how to save the file.\n * @param {string} [options.filename=file] - The name to use for the file being saved.\n * @param {string} [options.type] - The type of data being saved.\n *\n * @throws {TypeError} - Thrown if data attempting to be saved as JSON fails to stringify.\n */\nfunction _saveData(data: any, options?: SaveOptions): void {\n\tlet filename = options?.filename || 'file';\n\tlet type = options?.type || 'text/plain'\n\n\t// Type shorthands\n\tswitch (type) {\n\t\tcase 'json':\n\t\t\ttype = 'application/json';\n\t\t\tbreak;\n\t\tcase 'csv':\n\t\t\ttype = 'text/csv';\n\t\t\tbreak;\n\t}\n\n\tif (type === 'application/json') {\n\t\t// May throw an error\n\t\tdata = JSON.stringify(data);\n\n\t\tfilename = _extendFilename(filename, 'json');\n\t} else if (type === 'text/csv') {\n\t\tif (typeof data !== 'string') {\n\t\t\tdata = csv.stringify(data, options);\n\t\t}\n\t\tfilename = _extendFilename(filename, 'csv');\n\t}\n\n\t// Construct a Blob and download it\n\tlet blob = new Blob(\n\t\t[data],\n\t\t{ type }\n\t);\n\n\t_saveBlob(blob, options);\n}\n\n/**\n * Download a file by using a Data URL to click an anchor.\n *\n * @param {string} dataUrl - The Data URL to download.\n * @param {string} filename - The name of the file to be downloaded.\n */\nfunction _downloadDataUrl(dataUrl: string, filename: string): void {\n\t$link = $link || document.createElement('a');\n\t$link.href = dataUrl;\n\t$link.download = filename;\n\t$link.click();\n\n\tURL.revokeObjectURL(dataUrl);\n}\n\n/**\n * Adds a file extension to a filename if it doesn't already have one.\n *\n * @param  {string} filename - The file name to extend\n * @param  {string} extension - The extension to add. Don't include the '.'\n *\n * @return {string} `${filename}.${extension}`\n */\nfunction _extendFilename(filename: string, extension: string): string {\n\tlet testPattern = new RegExp('\\\\.' + extension + '$');\n\n\tif (!testPattern.test(filename)) {\n\t\tfilename += '.' + extension;\n\t}\n\n\treturn filename;\n}\n\nexport { save };\n","import * as fileIO from '@cipscis/fileio';\n\nconst loadImage = (fileUrl: string) => {\n\tconst $image = document.querySelectorAll('.js-fileio-image') as NodeListOf<HTMLImageElement>;\n\t$image.forEach(($image) => $image.src = fileUrl);\n};\ndocument.querySelectorAll('.js-load-image').forEach(($el) => $el.addEventListener('click', () => {\n\tfileIO.load(fileIO.ReadMethod.DataUrl).then(loadImage);\n}));\n\nconst saveData = () => {\n\tconst data = 'Hey look, the file has some content!';\n\tconst filename = 'test file.txt';\n\tconst type = 'text/plain';\n\n\tfileIO.save(data, { filename, type });\n};\ndocument.querySelectorAll('.js-save-data').forEach(($el) => $el.addEventListener('click', saveData));\n\nconst saveJson = () => {\n\tconst data = {\n\t\ttext: 1,\n\t\tfoo: 'bar'\n\t};\n\tconst filename = 'test json';\n\n\tfileIO.save(data, { filename, type: 'json' });\n};\ndocument.querySelectorAll('.js-save-json').forEach(($el) => $el.addEventListener('click', saveJson));\n\nconst saveCsv = () => {\n\tconst data = [\n\t\t['even numbers', 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24],\n\t\t['odd numbers', 1, 3, 5, 7, 9],\n\t\t['prime numbers, up to ten', 2, 3, 5, 7]\n\t];\n\tconst filename = 'test csv';\n\n\tfileIO.save(data, {filename, type: 'csv', transpose: true });\n};\ndocument.querySelectorAll('.js-save-csv').forEach(($el) => $el.addEventListener('click', saveCsv));\n\nconst saveFile = async () => {\n\tconst file = await fileIO.load(fileIO.ReadMethod.File);\n\tfileIO.save(file);\n};\ndocument.querySelectorAll('.js-save-file').forEach(($el) => $el.addEventListener('click', saveFile));\n"],"names":["ReadMethod","load","readMethod","Text","Promise","resolve","reject","fileLoaded","e","reader","this","readyState","FileReader","DONE","result","error","DOMException","$fileInput","document","createElement","type","addEventListener","files","length","file","File","abort","ArrayBuffer","readAsArrayBuffer","BinaryString","readAsBinaryString","DataUrl","readAsDataURL","readAsText","RangeError","readFile","click","_escapeCell","cell","options","cellString","sanitise","match","replace","$link","save","data","TypeError","filename","name","navigator","msSaveBlob","_downloadDataUrl","_saveFile","Blob","_saveBlob","JSON","stringify","_extendFilename","transpose","rows","rowStrings","i","push","join","_join","row","j","_escape","maxLength","reduce","Math","max","iMax","jMax","iRow","iCol","cellValue","_shape","_saveData","blob","URL","createObjectURL","dataUrl","href","download","revokeObjectURL","extension","RegExp","test","loadImage","fileUrl","querySelectorAll","forEach","$image","src","$el","then","saveData","saveJson","text","foo","saveCsv","saveFile","async"],"sourceRoot":""}